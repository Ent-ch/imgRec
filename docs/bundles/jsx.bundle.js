/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/App.jsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/geo-position/index.js":
/*!********************************************!*\
  !*** ./node_modules/geo-position/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var once = __webpack_require__(/*! once */ \"./node_modules/geo-position/node_modules/once/once.js\");\nvar o = __webpack_require__(/*! obj */ \"./node_modules/obj/index.js\");\n\nmodule.exports = getPosition;\n\nfunction getPosition (opts, fn) {\n  if (arguments.length == 1) {\n    fn = opts;\n    opts = {};\n  }\n\n  fn = once(fn);\n\n  unlessDefined(opts, {\n    timeout: 5000,\n    maximumAge: 60000,\n    enableHighAccuracy: true\n  });\n\n  navigator.geolocation.getCurrentPosition(onposition, fn, opts);\n\n  function onposition (position) {\n    fn(null, o(position.coords)\n              .clone()\n              .set('timestamp', position.timestamp)\n              .get());\n  };\n}\n\nfunction unlessDefined (base, xtend) {\n  o(xtend).each(function (key, value) {\n    if (typeof base[key] == 'undefined') base[key] = value;\n  });\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/geo-position/index.js?");

/***/ }),

/***/ "./node_modules/geo-position/node_modules/once/once.js":
/*!*************************************************************!*\
  !*** ./node_modules/geo-position/node_modules/once/once.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = once\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var called = false\n  return function () {\n    if (called) return\n    called = true\n    return fn.apply(this, arguments)\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/geo-position/node_modules/once/once.js?");

/***/ }),

/***/ "./node_modules/inferno/dist/index.esm.js":
/*!************************************************!*\
  !*** ./node_modules/inferno/dist/index.esm.js ***!
  \************************************************/
/*! exports provided: Component, EMPTY_OBJ, NO_OP, createComponentVNode, createPortal, createRenderer, createTextVNode, createVNode, directClone, getFlagsForElementVnode, getNumberStyleValue, hydrate, linkEvent, normalizeProps, options, render, version, JSX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_OBJ\", function() { return EMPTY_OBJ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NO_OP\", function() { return NO_OP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createComponentVNode\", function() { return createComponentVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return createPortal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRenderer\", function() { return createRenderer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createTextVNode\", function() { return createTextVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createVNode\", function() { return createVNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"directClone\", function() { return directClone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFlagsForElementVnode\", function() { return getFlagsForElementVnode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNumberStyleValue\", function() { return getNumberStyleValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hydrate\", function() { return hydrate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linkEvent\", function() { return linkEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeProps\", function() { return normalizeProps; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return options; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JSX\", function() { return JSX; });\nvar NO_OP = '$NO_OP';\nvar ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';\nvar isBrowser = !!(typeof window !== 'undefined' && window.document);\nvar isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(o) {\n    return isUndefined(o) || isNull(o);\n}\nfunction isInvalid(o) {\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\n}\nfunction isFunction(o) {\n    return typeof o === 'function';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isNumber(o) {\n    return typeof o === 'number';\n}\nfunction isNull(o) {\n    return o === null;\n}\nfunction isTrue(o) {\n    return o === true;\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\nfunction throwError(message) {\n    if (!message) {\n        message = ERROR_MSG;\n    }\n    throw new Error((\"Inferno Error: \" + message));\n}\nfunction combineFrom(first, second) {\n    var out = {};\n    if (first) {\n        for (var key in first) {\n            out[key] = first[key];\n        }\n    }\n    if (second) {\n        for (var key$1 in second) {\n            out[key$1] = second[key$1];\n        }\n    }\n    return out;\n}\n\nvar keyPrefix = '$';\nfunction getVNode(childFlags, children, className, flags, key, props, ref, type) {\n    return {\n        childFlags: childFlags,\n        children: children,\n        className: className,\n        dom: null,\n        flags: flags,\n        key: key === void 0 ? null : key,\n        parentVNode: null,\n        props: props === void 0 ? null : props,\n        ref: ref === void 0 ? null : ref,\n        type: type\n    };\n}\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;\n    var vNode = getVNode(childFlag, children, className, flags, key, props, ref, type);\n    var optsVNode = options.createVNode;\n    if (typeof optsVNode === 'function') {\n        optsVNode(vNode);\n    }\n    if (childFlag === 0 /* UnknownChildren */) {\n        normalizeChildren(vNode, vNode.children);\n    }\n    return vNode;\n}\nfunction createComponentVNode(flags, type, props, key, ref) {\n    if ((flags & 2 /* ComponentUnknown */) > 0) {\n        flags = type.prototype && isFunction(type.prototype.render) ? 4 /* ComponentClass */ : 8 /* ComponentFunction */;\n    }\n    // set default props\n    var defaultProps = type.defaultProps;\n    if (!isNullOrUndef(defaultProps)) {\n        if (!props) {\n            props = {}; // Props can be referenced and modified at application level so always create new object\n        }\n        for (var prop in defaultProps) {\n            if (isUndefined(props[prop])) {\n                props[prop] = defaultProps[prop];\n            }\n        }\n    }\n    if ((flags & 8 /* ComponentFunction */) > 0) {\n        var defaultHooks = type.defaultHooks;\n        if (!isNullOrUndef(defaultHooks)) {\n            if (!ref) {\n                // As ref cannot be referenced from application level, we can use the same refs object\n                ref = defaultHooks;\n            }\n            else {\n                for (var prop$1 in defaultHooks) {\n                    if (isUndefined(ref[prop$1])) {\n                        ref[prop$1] = defaultHooks[prop$1];\n                    }\n                }\n            }\n        }\n    }\n    var vNode = getVNode(1 /* HasInvalidChildren */, null, null, flags, key, props, ref, type);\n    var optsVNode = options.createVNode;\n    if (isFunction(optsVNode)) {\n        optsVNode(vNode);\n    }\n    return vNode;\n}\nfunction createTextVNode(text, key) {\n    return getVNode(1 /* HasInvalidChildren */, isNullOrUndef(text) ? '' : text, null, 16 /* Text */, key, null, null, null);\n}\nfunction normalizeProps(vNode) {\n    var props = vNode.props;\n    if (props) {\n        var flags = vNode.flags;\n        if (flags & 481 /* Element */) {\n            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n                normalizeChildren(vNode, props.children);\n            }\n            if (props.className !== void 0) {\n                vNode.className = props.className || null;\n                props.className = undefined;\n            }\n        }\n        if (props.key !== void 0) {\n            vNode.key = props.key;\n            props.key = undefined;\n        }\n        if (props.ref !== void 0) {\n            if (flags & 8 /* ComponentFunction */) {\n                vNode.ref = combineFrom(vNode.ref, props.ref);\n            }\n            else {\n                vNode.ref = props.ref;\n            }\n            props.ref = undefined;\n        }\n    }\n    return vNode;\n}\nfunction directClone(vNodeToClone) {\n    var newVNode;\n    var flags = vNodeToClone.flags;\n    if (flags & 14 /* Component */) {\n        var props;\n        var propsToClone = vNodeToClone.props;\n        if (!isNull(propsToClone)) {\n            props = {};\n            for (var key in propsToClone) {\n                props[key] = propsToClone[key];\n            }\n        }\n        newVNode = createComponentVNode(flags, vNodeToClone.type, props, vNodeToClone.key, vNodeToClone.ref);\n    }\n    else if (flags & 481 /* Element */) {\n        newVNode = createVNode(flags, vNodeToClone.type, vNodeToClone.className, vNodeToClone.children, vNodeToClone.childFlags, vNodeToClone.props, vNodeToClone.key, vNodeToClone.ref);\n    }\n    else if (flags & 16 /* Text */) {\n        newVNode = createTextVNode(vNodeToClone.children, vNodeToClone.key);\n    }\n    else if (flags & 1024 /* Portal */) {\n        newVNode = vNodeToClone;\n    }\n    return newVNode;\n}\nfunction createVoidVNode() {\n    return createTextVNode('', null);\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (var len = nodes.length; index < len; index++) {\n        var n = nodes[index];\n        if (!isInvalid(n)) {\n            var newKey = currentKey + keyPrefix + index;\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, newKey);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n, newKey);\n                }\n                else {\n                    var oldKey = n.key;\n                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n                    if (!isNull(n.dom) || isPrefixedKey) {\n                        n = directClone(n);\n                    }\n                    if (isNull(oldKey) || isPrefixedKey) {\n                        n.key = newKey;\n                    }\n                    else {\n                        n.key = currentKey + oldKey;\n                    }\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction getFlagsForElementVnode(type) {\n    if (type === 'svg') {\n        return 32 /* SvgElement */;\n    }\n    if (type === 'input') {\n        return 64 /* InputElement */;\n    }\n    if (type === 'select') {\n        return 256 /* SelectElement */;\n    }\n    if (type === 'textarea') {\n        return 128 /* TextareaElement */;\n    }\n    return 1 /* HtmlElement */;\n}\nfunction normalizeChildren(vNode, children) {\n    var newChildren;\n    var newChildFlags = 1 /* HasInvalidChildren */;\n    // Don't change children to match strict equal (===) true in patching\n    if (isInvalid(children)) {\n        newChildren = children;\n    }\n    else if (isString(children)) {\n        newChildFlags = 2 /* HasVNodeChildren */;\n        newChildren = createTextVNode(children);\n    }\n    else if (isNumber(children)) {\n        newChildFlags = 2 /* HasVNodeChildren */;\n        newChildren = createTextVNode(children + '');\n    }\n    else if (isArray(children)) {\n        var len = children.length;\n        if (len === 0) {\n            newChildren = null;\n            newChildFlags = 1 /* HasInvalidChildren */;\n        }\n        else {\n            // we assign $ which basically means we've flagged this array for future note\n            // if it comes back again, we need to clone it, as people are using it\n            // in an immutable way\n            // tslint:disable-next-line\n            if (Object.isFrozen(children) || children['$'] === true) {\n                children = children.slice();\n            }\n            newChildFlags = 8 /* HasKeyedChildren */;\n            for (var i = 0; i < len; i++) {\n                var n = children[i];\n                if (isInvalid(n) || isArray(n)) {\n                    newChildren = newChildren || children.slice(0, i);\n                    _normalizeVNodes(children, newChildren, i, '');\n                    break;\n                }\n                else if (isStringOrNumber(n)) {\n                    newChildren = newChildren || children.slice(0, i);\n                    newChildren.push(createTextVNode(n, keyPrefix + i));\n                }\n                else {\n                    var key = n.key;\n                    var isNullDom = isNull(n.dom);\n                    var isNullKey = isNull(key);\n                    var isPrefixed = !isNullKey && isString(key) && key[0] === keyPrefix;\n                    if (!isNullDom || isNullKey || isPrefixed) {\n                        newChildren = newChildren || children.slice(0, i);\n                        if (!isNullDom || isPrefixed) {\n                            n = directClone(n);\n                        }\n                        if (isNullKey || isPrefixed) {\n                            n.key = keyPrefix + i;\n                        }\n                        newChildren.push(n);\n                    }\n                    else if (newChildren) {\n                        newChildren.push(n);\n                    }\n                }\n            }\n            newChildren = newChildren || children;\n            newChildren.$ = true;\n        }\n    }\n    else {\n        newChildren = children;\n        if (!isNull(children.dom)) {\n            newChildren = directClone(children);\n        }\n        newChildFlags = 2 /* HasVNodeChildren */;\n    }\n    vNode.children = newChildren;\n    vNode.childFlags = newChildFlags;\n    return vNode;\n}\nvar options = {\n    afterRender: null,\n    beforeRender: null,\n    createVNode: null,\n    renderComplete: null\n};\n\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n    if (isFunction(event)) {\n        return { data: data, event: event };\n    }\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar svgNS = 'http://www.w3.org/2000/svg';\nvar namespaces = {\n    'xlink:actuate': xlinkNS,\n    'xlink:arcrole': xlinkNS,\n    'xlink:href': xlinkNS,\n    'xlink:role': xlinkNS,\n    'xlink:show': xlinkNS,\n    'xlink:title': xlinkNS,\n    'xlink:type': xlinkNS,\n    'xml:base': xmlNS,\n    'xml:lang': xmlNS,\n    'xml:space': xmlNS\n};\n\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nvar EMPTY_OBJ = {};\nvar LIFECYCLE = [];\nfunction appendChild(parentDom, dom) {\n    parentDom.appendChild(dom);\n}\nfunction insertOrAppend(parentDom, newNode, nextNode) {\n    if (isNullOrUndef(nextNode)) {\n        appendChild(parentDom, newNode);\n    }\n    else {\n        parentDom.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG) {\n        return document.createElementNS(svgNS, tag);\n    }\n    return document.createElement(tag);\n}\nfunction replaceChild(parentDom, newDom, lastDom) {\n    parentDom.replaceChild(newDom, lastDom);\n}\nfunction removeChild(parentDom, dom) {\n    parentDom.removeChild(dom);\n}\nfunction callAll(arrayFn) {\n    var listener;\n    while ((listener = arrayFn.shift()) !== undefined) {\n        listener();\n    }\n}\n\nvar attachedEventCounts = {};\nvar attachedEvents = {};\nfunction handleEvent(name, nextEvent, dom) {\n    var eventsLeft = attachedEventCounts[name];\n    var eventsObject = dom.$EV;\n    if (nextEvent) {\n        if (!eventsLeft) {\n            attachedEvents[name] = attachEventToDocument(name);\n            attachedEventCounts[name] = 0;\n        }\n        if (!eventsObject) {\n            eventsObject = dom.$EV = {};\n        }\n        if (!eventsObject[name]) {\n            attachedEventCounts[name]++;\n        }\n        eventsObject[name] = nextEvent;\n    }\n    else if (eventsObject && eventsObject[name]) {\n        attachedEventCounts[name]--;\n        if (eventsLeft === 1) {\n            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n            attachedEvents[name] = null;\n        }\n        eventsObject[name] = nextEvent;\n    }\n}\nfunction dispatchEvents(event, target, isClick, name, eventData) {\n    var dom = target;\n    while (!isNull(dom)) {\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n        // because the event listener is on document.body\n        // Don't process clicks on disabled elements\n        if (isClick && dom.disabled) {\n            return;\n        }\n        var eventsObject = dom.$EV;\n        if (eventsObject) {\n            var currentEvent = eventsObject[name];\n            if (currentEvent) {\n                // linkEvent object\n                eventData.dom = dom;\n                if (currentEvent.event) {\n                    currentEvent.event(currentEvent.data, event);\n                }\n                else {\n                    currentEvent(event);\n                }\n                if (event.cancelBubble) {\n                    return;\n                }\n            }\n        }\n        dom = dom.parentNode;\n    }\n}\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction stopPropagation() {\n    this.cancelBubble = true;\n    if (!this.immediatePropagationStopped) {\n        this.stopImmediatePropagation();\n    }\n}\nfunction attachEventToDocument(name) {\n    var docEvent = function (event) {\n        var type = event.type;\n        var isClick = type === 'click' || type === 'dblclick';\n        if (isClick && event.button !== 0) {\n            // Firefox incorrectly triggers click event for mid/right mouse buttons.\n            // This bug has been active for 12 years.\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n            event.stopPropagation();\n            return false;\n        }\n        event.stopPropagation = stopPropagation;\n        // Event data needs to be object to save reference to currentTarget getter\n        var eventData = {\n            dom: document\n        };\n        Object.defineProperty(event, 'currentTarget', {\n            configurable: true,\n            get: function get() {\n                return eventData.dom;\n            }\n        });\n        dispatchEvents(event, event.target, isClick, name, eventData);\n        return;\n    };\n    document.addEventListener(normalizeEventName(name), docEvent);\n    return docEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n    var tempdom = document.createElement('i');\n    tempdom.innerHTML = innerHTML;\n    return tempdom.innerHTML === dom.innerHTML;\n}\nfunction isSamePropsInnerHTML(dom, props) {\n    return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML(dom, props.dangerouslySetInnerHTML.__html));\n}\n\nfunction triggerEventListener(props, methodName, e) {\n    if (props[methodName]) {\n        var listener = props[methodName];\n        if (listener.event) {\n            listener.event(listener.data, e);\n        }\n        else {\n            listener(e);\n        }\n    }\n    else {\n        var nativeListenerName = methodName.toLowerCase();\n        if (props[nativeListenerName]) {\n            props[nativeListenerName](e);\n        }\n    }\n}\nfunction createWrappedFunction(methodName, applyValue) {\n    var fnMethod = function (e) {\n        e.stopPropagation();\n        var vNode = this.$V;\n        // If vNode is gone by the time event fires, no-op\n        if (!vNode) {\n            return;\n        }\n        var props = vNode.props || EMPTY_OBJ;\n        var dom = vNode.dom;\n        if (isString(methodName)) {\n            triggerEventListener(props, methodName, e);\n        }\n        else {\n            for (var i = 0; i < methodName.length; i++) {\n                triggerEventListener(props, methodName[i], e);\n            }\n        }\n        if (isFunction(applyValue)) {\n            var newVNode = this.$V;\n            var newProps = newVNode.props || EMPTY_OBJ;\n            applyValue(newProps, dom, false, newVNode);\n        }\n    };\n    Object.defineProperty(fnMethod, 'wrapped', {\n        configurable: false,\n        enumerable: false,\n        value: true,\n        writable: false\n    });\n    return fnMethod;\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\nfunction emptywrapper(event) {\n    event.stopPropagation();\n}\nemptywrapper.wrapped = true;\nfunction inputEvents(dom, nextPropsOrEmpty) {\n    if (isCheckedType(nextPropsOrEmpty.type)) {\n        dom.onchange = wrappedOnChange;\n        dom.onclick = emptywrapper;\n    }\n    else {\n        dom.oninput = onTextInputChange;\n    }\n}\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n    var type = nextPropsOrEmpty.type;\n    var value = nextPropsOrEmpty.value;\n    var checked = nextPropsOrEmpty.checked;\n    var multiple = nextPropsOrEmpty.multiple;\n    var defaultValue = nextPropsOrEmpty.defaultValue;\n    var hasValue = !isNullOrUndef(value);\n    if (type && type !== dom.type) {\n        dom.setAttribute('type', type);\n    }\n    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\n        dom.defaultValue = defaultValue + '';\n    }\n    if (isCheckedType(type)) {\n        if (hasValue) {\n            dom.value = value;\n        }\n        if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n    else {\n        if (hasValue && dom.value !== value) {\n            dom.defaultValue = value;\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction updateChildOptionGroup(vNode, value) {\n    var type = vNode.type;\n    if (type === 'optgroup') {\n        var children = vNode.children;\n        var childFlags = vNode.childFlags;\n        if (childFlags & 12 /* MultipleChildren */) {\n            for (var i = 0, len = children.length; i < len; i++) {\n                updateChildOption(children[i], value);\n            }\n        }\n        else if (childFlags === 2 /* HasVNodeChildren */) {\n            updateChildOption(children, value);\n        }\n    }\n    else {\n        updateChildOption(vNode, value);\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if ((isArray(value) && value.indexOf(props.value) !== -1) || props.value === value) {\n        dom.selected = true;\n    }\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n        dom.selected = props.selected || false;\n    }\n}\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\nfunction selectEvents(dom) {\n    dom.onchange = onSelectChange;\n}\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n        dom.multiple = multiplePropInBoolean;\n    }\n    var childFlags = vNode.childFlags;\n    if ((childFlags & 1 /* HasInvalidChildren */) === 0) {\n        var children = vNode.children;\n        var value = nextPropsOrEmpty.value;\n        if (mounting && isNullOrUndef(value)) {\n            value = nextPropsOrEmpty.defaultValue;\n        }\n        if (childFlags & 12 /* MultipleChildren */) {\n            for (var i = 0, len = children.length; i < len; i++) {\n                updateChildOptionGroup(children[i], value);\n            }\n        }\n        else if (childFlags === 2 /* HasVNodeChildren */) {\n            updateChildOptionGroup(children, value);\n        }\n    }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n    dom.oninput = onTextareaInputChange;\n    if (nextPropsOrEmpty.onChange) {\n        dom.onchange = wrappedOnChange$1;\n    }\n}\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n    var value = nextPropsOrEmpty.value;\n    var domValue = dom.value;\n    if (isNullOrUndef(value)) {\n        if (mounting) {\n            var defaultValue = nextPropsOrEmpty.defaultValue;\n            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n                dom.defaultValue = defaultValue;\n                dom.value = defaultValue;\n            }\n        }\n    }\n    else if (domValue !== value) {\n        /* There is value so keep it controlled */\n        dom.defaultValue = value;\n        dom.value = value;\n    }\n}\n\n/**\n * There is currently no support for switching same input between controlled and nonControlled\n * If that ever becomes a real issue, then re design controlled elements\n * Currently user must choose either controlled or non-controlled and stick with that\n */\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    if (flags & 64 /* InputElement */) {\n        applyValueInput(nextPropsOrEmpty, dom);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n    }\n    if (isControlled) {\n        dom.$V = vNode;\n    }\n}\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n    if (flags & 64 /* InputElement */) {\n        inputEvents(dom, nextPropsOrEmpty);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        selectEvents(dom);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        textAreaEvents(dom, nextPropsOrEmpty);\n    }\n}\nfunction isControlledFormElement(nextPropsOrEmpty) {\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction remove(vNode, parentDom) {\n    unmount(vNode);\n    if (parentDom && vNode.dom) {\n        removeChild(parentDom, vNode.dom);\n        // Let carbage collector free memory\n        vNode.dom = null;\n    }\n}\nfunction unmount(vNode) {\n    var flags = vNode.flags;\n    if (flags & 481 /* Element */) {\n        var ref = vNode.ref;\n        var props = vNode.props;\n        if (isFunction(ref)) {\n            ref(null);\n        }\n        var children = vNode.children;\n        var childFlags = vNode.childFlags;\n        if (childFlags & 12 /* MultipleChildren */) {\n            unmountAllChildren(children);\n        }\n        else if (childFlags === 2 /* HasVNodeChildren */) {\n            unmount(children);\n        }\n        if (!isNull(props)) {\n            for (var name in props) {\n                switch (name) {\n                    case 'onClick':\n                    case 'onDblClick':\n                    case 'onFocusIn':\n                    case 'onFocusOut':\n                    case 'onKeyDown':\n                    case 'onKeyPress':\n                    case 'onKeyUp':\n                    case 'onMouseDown':\n                    case 'onMouseMove':\n                    case 'onMouseUp':\n                    case 'onSubmit':\n                    case 'onTouchEnd':\n                    case 'onTouchMove':\n                    case 'onTouchStart':\n                        handleEvent(name, null, vNode.dom);\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    }\n    else {\n        var children$1 = vNode.children;\n        // Safe guard for crashed VNode\n        if (children$1) {\n            if (flags & 14 /* Component */) {\n                var ref$1 = vNode.ref;\n                if (flags & 4 /* ComponentClass */) {\n                    if (isFunction(children$1.componentWillUnmount)) {\n                        children$1.componentWillUnmount();\n                    }\n                    if (isFunction(ref$1)) {\n                        ref$1(null);\n                    }\n                    children$1.$UN = true;\n                    if (children$1.$LI) {\n                        unmount(children$1.$LI);\n                    }\n                }\n                else {\n                    if (!isNullOrUndef(ref$1) && isFunction(ref$1.onComponentWillUnmount)) {\n                        ref$1.onComponentWillUnmount(vNode.dom, vNode.props || EMPTY_OBJ);\n                    }\n                    unmount(children$1);\n                }\n            }\n            else if (flags & 1024 /* Portal */) {\n                remove(children$1, vNode.type);\n            }\n        }\n    }\n}\nfunction unmountAllChildren(children) {\n    for (var i = 0, len = children.length; i < len; i++) {\n        unmount(children[i]);\n    }\n}\nfunction removeAllChildren(dom, children) {\n    unmountAllChildren(children);\n    dom.textContent = '';\n}\n\nfunction createLinkEvent(linkEvent, nextValue) {\n    return function (e) {\n        linkEvent(nextValue.data, e);\n    };\n}\nfunction patchEvent(name, nextValue, dom) {\n    var nameLowerCase = name.toLowerCase();\n    if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {\n        var linkEvent = nextValue.event;\n        if (linkEvent && isFunction(linkEvent)) {\n            dom[nameLowerCase] = createLinkEvent(linkEvent, nextValue);\n        }\n    }\n    else {\n        var domEvent = dom[nameLowerCase];\n        // if the function is wrapped, that means it's been controlled by a wrapper\n        if (!domEvent || !domEvent.wrapped) {\n            dom[nameLowerCase] = nextValue;\n        }\n    }\n}\nfunction getNumberStyleValue(style, value) {\n    switch (style) {\n        case 'animationIterationCount':\n        case 'borderImageOutset':\n        case 'borderImageSlice':\n        case 'borderImageWidth':\n        case 'boxFlex':\n        case 'boxFlexGroup':\n        case 'boxOrdinalGroup':\n        case 'columnCount':\n        case 'fillOpacity':\n        case 'flex':\n        case 'flexGrow':\n        case 'flexNegative':\n        case 'flexOrder':\n        case 'flexPositive':\n        case 'flexShrink':\n        case 'floodOpacity':\n        case 'fontWeight':\n        case 'gridColumn':\n        case 'gridRow':\n        case 'lineClamp':\n        case 'lineHeight':\n        case 'opacity':\n        case 'order':\n        case 'orphans':\n        case 'stopOpacity':\n        case 'strokeDasharray':\n        case 'strokeDashoffset':\n        case 'strokeMiterlimit':\n        case 'strokeOpacity':\n        case 'strokeWidth':\n        case 'tabSize':\n        case 'widows':\n        case 'zIndex':\n        case 'zoom':\n            return value;\n        default:\n            return value + 'px';\n    }\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    var domStyle = dom.style;\n    var style;\n    var value;\n    if (isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n        for (style in nextAttrValue) {\n            // do not add a hasOwnProperty check here, it affects performance\n            value = nextAttrValue[style];\n            if (value !== lastAttrValue[style]) {\n                domStyle[style] = isNumber(value) ? getNumberStyleValue(style, value) : value;\n            }\n        }\n        for (style in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style])) {\n                domStyle[style] = '';\n            }\n        }\n    }\n    else {\n        for (style in nextAttrValue) {\n            value = nextAttrValue[style];\n            domStyle[style] = isNumber(value) ? getNumberStyleValue(style, value) : value;\n        }\n    }\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n    switch (prop) {\n        case 'onClick':\n        case 'onDblClick':\n        case 'onFocusIn':\n        case 'onFocusOut':\n        case 'onKeyDown':\n        case 'onKeyPress':\n        case 'onKeyUp':\n        case 'onMouseDown':\n        case 'onMouseMove':\n        case 'onMouseUp':\n        case 'onSubmit':\n        case 'onTouchEnd':\n        case 'onTouchMove':\n        case 'onTouchStart':\n            handleEvent(prop, nextValue, dom);\n            break;\n        case 'children':\n        case 'childrenType':\n        case 'className':\n        case 'defaultValue':\n        case 'key':\n        case 'multiple':\n        case 'ref':\n            break;\n        case 'autoFocus':\n            dom.autofocus = !!nextValue;\n            break;\n        case 'allowfullscreen':\n        case 'autoplay':\n        case 'capture':\n        case 'checked':\n        case 'controls':\n        case 'default':\n        case 'disabled':\n        case 'hidden':\n        case 'indeterminate':\n        case 'loop':\n        case 'muted':\n        case 'novalidate':\n        case 'open':\n        case 'readOnly':\n        case 'required':\n        case 'reversed':\n        case 'scoped':\n        case 'seamless':\n        case 'selected':\n            dom[prop] = !!nextValue;\n            break;\n        case 'defaultChecked':\n        case 'value':\n        case 'volume':\n            if (hasControlledValue && prop === 'value') {\n                return;\n            }\n            var value = isNullOrUndef(nextValue) ? '' : nextValue;\n            if (dom[prop] !== value) {\n                dom[prop] = value;\n            }\n            break;\n        case 'dangerouslySetInnerHTML':\n            var lastHtml = (lastValue && lastValue.__html) || '';\n            var nextHtml = (nextValue && nextValue.__html) || '';\n            if (lastHtml !== nextHtml) {\n                if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n                    if (!isNull(lastVNode)) {\n                        if (lastVNode.childFlags & 12 /* MultipleChildren */) {\n                            unmountAllChildren(lastVNode.children);\n                        }\n                        else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {\n                            unmount(lastVNode.children);\n                        }\n                        lastVNode.children = null;\n                        lastVNode.childFlags = 1 /* HasInvalidChildren */;\n                    }\n                    dom.innerHTML = nextHtml;\n                }\n            }\n            break;\n        default:\n            if (prop[0] === 'o' && prop[1] === 'n') {\n                patchEvent(prop, nextValue, dom);\n            }\n            else if (isNullOrUndef(nextValue)) {\n                dom.removeAttribute(prop);\n            }\n            else if (prop === 'style') {\n                patchStyle(lastValue, nextValue, dom);\n            }\n            else if (isSVG && namespaces[prop]) {\n                // We optimize for isSVG being false\n                // If we end up in this path we can read property again\n                dom.setAttributeNS(namespaces[prop], prop, nextValue);\n            }\n            else {\n                dom.setAttribute(prop, nextValue);\n            }\n            break;\n    }\n}\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n    var hasControlledValue = false;\n    var isFormElement = (flags & 448 /* FormElement */) > 0;\n    if (isFormElement) {\n        hasControlledValue = isControlledFormElement(props);\n        if (hasControlledValue) {\n            addFormElementEventHandlers(flags, dom, props);\n        }\n    }\n    for (var prop in props) {\n        // do not add a hasOwnProperty check here, it affects performance\n        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n    }\n    if (isFormElement) {\n        processElement(flags, vNode, dom, props, true, hasControlledValue);\n    }\n}\n\nfunction createClassComponentInstance(vNode, Component, props, context) {\n    var instance = new Component(props, context);\n    vNode.children = instance;\n    instance.$V = vNode;\n    instance.$BS = false;\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    instance.$UN = false;\n    if (isFunction(instance.componentWillMount)) {\n        instance.$BR = true;\n        instance.componentWillMount();\n        if (instance.$PSS) {\n            var state = instance.state;\n            var pending = instance.$PS;\n            if (isNull(state)) {\n                instance.state = pending;\n            }\n            else {\n                for (var key in pending) {\n                    state[key] = pending[key];\n                }\n            }\n            instance.$PSS = false;\n            instance.$PS = null;\n        }\n        instance.$BR = false;\n    }\n    if (isFunction(options.beforeRender)) {\n        options.beforeRender(instance);\n    }\n    var input = handleComponentInput(instance.render(props, instance.state, context), vNode);\n    var childContext;\n    if (isFunction(instance.getChildContext)) {\n        childContext = instance.getChildContext();\n    }\n    if (isNullOrUndef(childContext)) {\n        instance.$CX = context;\n    }\n    else {\n        instance.$CX = combineFrom(context, childContext);\n    }\n    if (isFunction(options.afterRender)) {\n        options.afterRender(instance);\n    }\n    instance.$LI = input;\n    return instance;\n}\nfunction handleComponentInput(input, componentVNode) {\n    if (isInvalid(input)) {\n        input = createVoidVNode();\n    }\n    else if (isStringOrNumber(input)) {\n        input = createTextVNode(input, null);\n    }\n    else {\n        if (input.dom) {\n            input = directClone(input);\n        }\n        if (input.flags & 14 /* Component */) {\n            // if we have an input that is also a component, we run into a tricky situation\n            // where the root vNode needs to always have the correct DOM entry\n            // we can optimise this in the future, but this gets us out of a lot of issues\n            input.parentVNode = componentVNode;\n        }\n    }\n    return input;\n}\n\nfunction mount(vNode, parentDom, context, isSVG) {\n    var flags = vNode.flags;\n    if (flags & 481 /* Element */) {\n        return mountElement(vNode, parentDom, context, isSVG);\n    }\n    if (flags & 14 /* Component */) {\n        return mountComponent(vNode, parentDom, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\n    }\n    if (flags & 512 /* Void */ || flags & 16 /* Text */) {\n        return mountText(vNode, parentDom);\n    }\n    if (flags & 1024 /* Portal */) {\n        mount(vNode.children, vNode.type, context, false);\n        return (vNode.dom = mountText(createVoidVNode(), parentDom));\n    }\n}\nfunction mountText(vNode, parentDom) {\n    var dom = (vNode.dom = document.createTextNode(vNode.children));\n    if (!isNull(parentDom)) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nfunction mountElement(vNode, parentDom, context, isSVG) {\n    var flags = vNode.flags;\n    var children = vNode.children;\n    var props = vNode.props;\n    var className = vNode.className;\n    var ref = vNode.ref;\n    var childFlags = vNode.childFlags;\n    isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;\n    var dom = documentCreateElement(vNode.type, isSVG);\n    vNode.dom = dom;\n    if (!isNullOrUndef(className) && className !== '') {\n        if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n    }\n    if (!isNull(parentDom)) {\n        appendChild(parentDom, dom);\n    }\n    if ((childFlags & 1 /* HasInvalidChildren */) === 0) {\n        var childrenIsSVG = isSVG === true && vNode.type !== 'foreignObject';\n        if (childFlags === 2 /* HasVNodeChildren */) {\n            mount(children, dom, context, childrenIsSVG);\n        }\n        else if (childFlags & 12 /* MultipleChildren */) {\n            mountArrayChildren(children, dom, context, childrenIsSVG);\n        }\n    }\n    if (!isNull(props)) {\n        mountProps(vNode, flags, props, dom, isSVG);\n    }\n    if (isFunction(ref)) {\n        mountRef(dom, ref);\n    }\n    return dom;\n}\nfunction mountArrayChildren(children, dom, context, isSVG) {\n    for (var i = 0, len = children.length; i < len; i++) {\n        var child = children[i];\n        if (!isNull(child.dom)) {\n            children[i] = child = directClone(child);\n        }\n        mount(child, dom, context, isSVG);\n    }\n}\nfunction mountComponent(vNode, parentDom, context, isSVG, isClass) {\n    var dom;\n    var type = vNode.type;\n    var props = vNode.props || EMPTY_OBJ;\n    var ref = vNode.ref;\n    if (isClass) {\n        var instance = createClassComponentInstance(vNode, type, props, context);\n        vNode.dom = dom = mount(instance.$LI, null, instance.$CX, isSVG);\n        mountClassComponentCallbacks(vNode, ref, instance);\n        instance.$UPD = false;\n    }\n    else {\n        var input = handleComponentInput(type(props, context), vNode);\n        vNode.children = input;\n        vNode.dom = dom = mount(input, null, context, isSVG);\n        mountFunctionalComponentCallbacks(props, ref, dom);\n    }\n    if (!isNull(parentDom)) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nfunction createClassMountCallback(instance) {\n    return function () {\n        instance.$UPD = true;\n        instance.componentDidMount();\n        instance.$UPD = false;\n    };\n}\nfunction mountClassComponentCallbacks(vNode, ref, instance) {\n    if (isFunction(ref)) {\n        ref(instance);\n    }\n    if (isFunction(instance.componentDidMount)) {\n        LIFECYCLE.push(createClassMountCallback(instance));\n    }\n}\nfunction createOnMountCallback(ref, dom, props) {\n    return function () { return ref.onComponentDidMount(dom, props); };\n}\nfunction mountFunctionalComponentCallbacks(props, ref, dom) {\n    if (!isNullOrUndef(ref)) {\n        if (isFunction(ref.onComponentWillMount)) {\n            ref.onComponentWillMount(props);\n        }\n        if (isFunction(ref.onComponentDidMount)) {\n            LIFECYCLE.push(createOnMountCallback(ref, dom, props));\n        }\n    }\n}\nfunction mountRef(dom, value) {\n    LIFECYCLE.push(function () { return value(dom); });\n}\n\nfunction hydrateComponent(vNode, dom, context, isSVG, isClass) {\n    var type = vNode.type;\n    var ref = vNode.ref;\n    var props = vNode.props || EMPTY_OBJ;\n    if (isClass) {\n        var instance = createClassComponentInstance(vNode, type, props, context);\n        var input = instance.$LI;\n        hydrateVNode(input, dom, instance.$CX, isSVG);\n        vNode.dom = input.dom;\n        mountClassComponentCallbacks(vNode, ref, instance);\n        instance.$UPD = false; // Mount finished allow going sync\n    }\n    else {\n        var input$1 = handleComponentInput(type(props, context), vNode);\n        hydrateVNode(input$1, dom, context, isSVG);\n        vNode.children = input$1;\n        vNode.dom = input$1.dom;\n        mountFunctionalComponentCallbacks(props, ref, dom);\n    }\n}\nfunction hydrateElement(vNode, dom, context, isSVG) {\n    var children = vNode.children;\n    var props = vNode.props;\n    var className = vNode.className;\n    var flags = vNode.flags;\n    var ref = vNode.ref;\n    isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;\n    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {\n        var newDom = mountElement(vNode, null, context, isSVG);\n        vNode.dom = newDom;\n        replaceChild(dom.parentNode, newDom, dom);\n    }\n    else {\n        vNode.dom = dom;\n        var childNode = dom.firstChild;\n        var childFlags = vNode.childFlags;\n        if ((childFlags & 1 /* HasInvalidChildren */) === 0) {\n            var nextSibling = null;\n            while (childNode) {\n                nextSibling = childNode.nextSibling;\n                if (childNode.nodeType === 8) {\n                    if (childNode.data === '!') {\n                        dom.replaceChild(document.createTextNode(''), childNode);\n                    }\n                    else {\n                        dom.removeChild(childNode);\n                    }\n                }\n                childNode = nextSibling;\n            }\n            childNode = dom.firstChild;\n            if (childFlags === 2 /* HasVNodeChildren */) {\n                if (isNull(childNode)) {\n                    mount(children, dom, context, isSVG);\n                }\n                else {\n                    nextSibling = childNode.nextSibling;\n                    hydrateVNode(children, childNode, context, isSVG);\n                    childNode = nextSibling;\n                }\n            }\n            else if (childFlags & 12 /* MultipleChildren */) {\n                for (var i = 0, len = children.length; i < len; i++) {\n                    var child = children[i];\n                    if (isNull(childNode)) {\n                        mount(child, dom, context, isSVG);\n                    }\n                    else {\n                        nextSibling = childNode.nextSibling;\n                        hydrateVNode(child, childNode, context, isSVG);\n                        childNode = nextSibling;\n                    }\n                }\n            }\n            // clear any other DOM nodes, there should be only a single entry for the root\n            while (childNode) {\n                nextSibling = childNode.nextSibling;\n                dom.removeChild(childNode);\n                childNode = nextSibling;\n            }\n        }\n        else if (!isNull(dom.firstChild) && !isSamePropsInnerHTML(dom, props)) {\n            dom.textContent = ''; // dom has content, but VNode has no children remove everything from DOM\n            if (flags & 448 /* FormElement */) {\n                // If element is form element, we need to clear defaultValue also\n                dom.defaultValue = '';\n            }\n        }\n        if (!isNull(props)) {\n            mountProps(vNode, flags, props, dom, isSVG);\n        }\n        if (isNullOrUndef(className)) {\n            if (dom.className !== '') {\n                dom.removeAttribute('class');\n            }\n        }\n        else if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n        if (isFunction(ref)) {\n            mountRef(dom, ref);\n        }\n    }\n}\nfunction hydrateText(vNode, dom) {\n    if (dom.nodeType !== 3) {\n        var newDom = mountText(vNode, null);\n        vNode.dom = newDom;\n        replaceChild(dom.parentNode, newDom, dom);\n    }\n    else {\n        var text = vNode.children;\n        if (dom.nodeValue !== text) {\n            dom.nodeValue = text;\n        }\n        vNode.dom = dom;\n    }\n}\nfunction hydrateVNode(vNode, dom, context, isSVG) {\n    var flags = vNode.flags;\n    if (flags & 14 /* Component */) {\n        hydrateComponent(vNode, dom, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\n    }\n    else if (flags & 481 /* Element */) {\n        hydrateElement(vNode, dom, context, isSVG);\n    }\n    else if (flags & 16 /* Text */) {\n        hydrateText(vNode, dom);\n    }\n    else if (flags & 512 /* Void */) {\n        vNode.dom = dom;\n    }\n    else {\n        throwError();\n    }\n}\nfunction hydrate(input, parentDom, callback) {\n    var dom = parentDom.firstChild;\n    if (!isNull(dom)) {\n        if (!isInvalid(input)) {\n            hydrateVNode(input, dom, EMPTY_OBJ, false);\n        }\n        dom = parentDom.firstChild;\n        // clear any other DOM nodes, there should be only a single entry for the root\n        while ((dom = dom.nextSibling)) {\n            parentDom.removeChild(dom);\n        }\n    }\n    if (LIFECYCLE.length > 0) {\n        callAll(LIFECYCLE);\n    }\n    parentDom.$V = input;\n    if (isFunction(callback)) {\n        callback();\n    }\n}\n\nfunction replaceWithNewNode(lastNode, nextNode, parentDom, context, isSVG) {\n    unmount(lastNode);\n    replaceChild(parentDom, mount(nextNode, null, context, isSVG), lastNode.dom);\n}\nfunction patch(lastVNode, nextVNode, parentDom, context, isSVG) {\n    var nextFlags = nextVNode.flags | 0;\n    if (lastVNode.flags !== nextFlags || nextFlags & 2048 /* ReCreate */) {\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, context, isSVG);\n    }\n    else if (nextFlags & 481 /* Element */) {\n        patchElement(lastVNode, nextVNode, parentDom, context, isSVG, nextFlags);\n    }\n    else if (nextFlags & 14 /* Component */) {\n        patchComponent(lastVNode, nextVNode, parentDom, context, isSVG, (nextFlags & 4 /* ComponentClass */) > 0);\n    }\n    else if (nextFlags & 16 /* Text */) {\n        patchText(lastVNode, nextVNode);\n    }\n    else if (nextFlags & 512 /* Void */) {\n        nextVNode.dom = lastVNode.dom;\n    }\n    else {\n        patchPortal(lastVNode, nextVNode, context);\n    }\n}\nfunction patchContentEditableChildren(dom, nextVNode) {\n    if (dom.textContent !== nextVNode.children) {\n        dom.textContent = nextVNode.children;\n    }\n}\nfunction patchPortal(lastVNode, nextVNode, context) {\n    var lastContainer = lastVNode.type;\n    var nextContainer = nextVNode.type;\n    var nextChildren = nextVNode.children;\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false);\n    nextVNode.dom = lastVNode.dom;\n    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n        var node = nextChildren.dom;\n        lastContainer.removeChild(node);\n        nextContainer.appendChild(node);\n    }\n}\nfunction patchElement(lastVNode, nextVNode, parentDom, context, isSVG, nextFlags) {\n    var nextTag = nextVNode.type;\n    if (lastVNode.type !== nextTag) {\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, context, isSVG);\n    }\n    else {\n        var dom = lastVNode.dom;\n        var lastProps = lastVNode.props;\n        var nextProps = nextVNode.props;\n        var isFormElement = false;\n        var hasControlledValue = false;\n        var nextPropsOrEmpty;\n        nextVNode.dom = dom;\n        isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;\n        // inlined patchProps  -- starts --\n        if (lastProps !== nextProps) {\n            var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n            nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n            if (nextPropsOrEmpty !== EMPTY_OBJ) {\n                isFormElement = (nextFlags & 448 /* FormElement */) > 0;\n                if (isFormElement) {\n                    hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n                }\n                for (var prop in nextPropsOrEmpty) {\n                    var lastValue = lastPropsOrEmpty[prop];\n                    var nextValue = nextPropsOrEmpty[prop];\n                    if (lastValue !== nextValue) {\n                        patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n                    }\n                }\n            }\n            if (lastPropsOrEmpty !== EMPTY_OBJ) {\n                for (var prop$1 in lastPropsOrEmpty) {\n                    if (!nextPropsOrEmpty.hasOwnProperty(prop$1) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n                        patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n                    }\n                }\n            }\n        }\n        var lastChildren = lastVNode.children;\n        var nextChildren = nextVNode.children;\n        var nextRef = nextVNode.ref;\n        var lastClassName = lastVNode.className;\n        var nextClassName = nextVNode.className;\n        if (nextFlags & 4096 /* ContentEditable */) {\n            patchContentEditableChildren(dom, nextChildren);\n        }\n        else {\n            patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastChildren, nextChildren, dom, context, isSVG && nextTag !== 'foreignObject');\n        }\n        if (isFormElement) {\n            processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n        }\n        // inlined patchProps  -- ends --\n        if (lastClassName !== nextClassName) {\n            if (isNullOrUndef(nextClassName)) {\n                dom.removeAttribute('class');\n            }\n            else if (isSVG) {\n                dom.setAttribute('class', nextClassName);\n            }\n            else {\n                dom.className = nextClassName;\n            }\n        }\n        if (isFunction(nextRef) && lastVNode.ref !== nextRef) {\n            mountRef(dom, nextRef);\n        }\n    }\n}\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG) {\n    switch (lastChildFlags) {\n        case 2 /* HasVNodeChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    patch(lastChildren, nextChildren, parentDOM, context, isSVG);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    remove(lastChildren, parentDOM);\n                    break;\n                default:\n                    remove(lastChildren, parentDOM);\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG);\n                    break;\n            }\n            break;\n        case 1 /* HasInvalidChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    mount(nextChildren, parentDOM, context, isSVG);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    break;\n                default:\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG);\n                    break;\n            }\n            break;\n        default:\n            if (nextChildFlags & 12 /* MultipleChildren */) {\n                var lastLength = lastChildren.length;\n                var nextLength = nextChildren.length;\n                // Fast path's for both algorithms\n                if (lastLength === 0) {\n                    if (nextLength > 0) {\n                        mountArrayChildren(nextChildren, parentDOM, context, isSVG);\n                    }\n                }\n                else if (nextLength === 0) {\n                    removeAllChildren(parentDOM, lastChildren);\n                }\n                else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {\n                    patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength);\n                }\n                else {\n                    patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength);\n                }\n            }\n            else if (nextChildFlags === 1 /* HasInvalidChildren */) {\n                removeAllChildren(parentDOM, lastChildren);\n            }\n            else if (nextChildFlags === 2 /* HasVNodeChildren */) {\n                removeAllChildren(parentDOM, lastChildren);\n                mount(nextChildren, parentDOM, context, isSVG);\n            }\n            break;\n    }\n}\nfunction updateClassComponent(instance, nextState, nextVNode, nextProps, parentDom, context, isSVG, force, fromSetState) {\n    var lastState = instance.state;\n    var lastProps = instance.props;\n    nextVNode.children = instance;\n    var renderOutput;\n    if (instance.$UN) {\n        return;\n    }\n    if (lastProps !== nextProps || nextProps === EMPTY_OBJ) {\n        if (!fromSetState && isFunction(instance.componentWillReceiveProps)) {\n            instance.$BR = true;\n            instance.componentWillReceiveProps(nextProps, context);\n            // If instance component was removed during its own update do nothing.\n            if (instance.$UN) {\n                return;\n            }\n            instance.$BR = false;\n        }\n        if (instance.$PSS) {\n            nextState = combineFrom(nextState, instance.$PS);\n            instance.$PSS = false;\n            instance.$PS = null;\n        }\n    }\n    /* Update if scu is not defined, or it returns truthy value or force */\n    var hasSCU = Boolean(instance.shouldComponentUpdate);\n    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {\n        if (isFunction(instance.componentWillUpdate)) {\n            instance.$BS = true;\n            instance.componentWillUpdate(nextProps, nextState, context);\n            instance.$BS = false;\n        }\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n        if (isFunction(options.beforeRender)) {\n            options.beforeRender(instance);\n        }\n        renderOutput = instance.render(nextProps, nextState, context);\n        if (isFunction(options.afterRender)) {\n            options.afterRender(instance);\n        }\n        var didUpdate = renderOutput !== NO_OP;\n        var childContext;\n        if (isFunction(instance.getChildContext)) {\n            childContext = instance.getChildContext();\n        }\n        if (isNullOrUndef(childContext)) {\n            childContext = context;\n        }\n        else {\n            childContext = combineFrom(context, childContext);\n        }\n        instance.$CX = childContext;\n        if (didUpdate) {\n            var lastInput = instance.$LI;\n            var nextInput = handleComponentInput(renderOutput, nextVNode);\n            patch(lastInput, nextInput, parentDom, childContext, isSVG);\n            instance.$LI = nextInput;\n            if (isFunction(instance.componentDidUpdate)) {\n                instance.componentDidUpdate(lastProps, lastState);\n            }\n        }\n    }\n    else {\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n    }\n    nextVNode.dom = instance.$LI.dom;\n}\nfunction patchComponent(lastVNode, nextVNode, parentDom, context, isSVG, isClass) {\n    var nextType = nextVNode.type;\n    var lastKey = lastVNode.key;\n    var nextKey = nextVNode.key;\n    if (lastVNode.type !== nextType || lastKey !== nextKey) {\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, context, isSVG);\n    }\n    else {\n        var nextProps = nextVNode.props || EMPTY_OBJ;\n        if (isClass) {\n            var instance = lastVNode.children;\n            instance.$UPD = true;\n            instance.$V = nextVNode;\n            updateClassComponent(instance, instance.state, nextVNode, nextProps, parentDom, context, isSVG, false, false);\n            instance.$UPD = false;\n        }\n        else {\n            var shouldUpdate = true;\n            var lastProps = lastVNode.props;\n            var nextHooks = nextVNode.ref;\n            var nextHooksDefined = !isNullOrUndef(nextHooks);\n            var lastInput = lastVNode.children;\n            nextVNode.dom = lastVNode.dom;\n            nextVNode.children = lastInput;\n            if (nextHooksDefined && isFunction(nextHooks.onComponentShouldUpdate)) {\n                shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps, nextProps);\n            }\n            if (shouldUpdate !== false) {\n                if (nextHooksDefined && isFunction(nextHooks.onComponentWillUpdate)) {\n                    nextHooks.onComponentWillUpdate(lastProps, nextProps);\n                }\n                var nextInput = nextType(nextProps, context);\n                if (nextInput !== NO_OP) {\n                    nextInput = handleComponentInput(nextInput, nextVNode);\n                    patch(lastInput, nextInput, parentDom, context, isSVG);\n                    nextVNode.children = nextInput;\n                    nextVNode.dom = nextInput.dom;\n                    if (nextHooksDefined && isFunction(nextHooks.onComponentDidUpdate)) {\n                        nextHooks.onComponentDidUpdate(lastProps, nextProps);\n                    }\n                }\n            }\n            else if (lastInput.flags & 14 /* Component */) {\n                lastInput.parentVNode = nextVNode;\n            }\n        }\n    }\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = lastVNode.dom;\n    if (nextText !== lastVNode.children) {\n        dom.nodeValue = nextText;\n    }\n    nextVNode.dom = dom;\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength) {\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    var nextChild;\n    var lastChild;\n    for (; i < commonLength; i++) {\n        nextChild = nextChildren[i];\n        lastChild = lastChildren[i];\n        if (nextChild.dom) {\n            nextChild = nextChildren[i] = directClone(nextChild);\n        }\n        patch(lastChild, nextChild, dom, context, isSVG);\n        lastChildren[i] = nextChild;\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; i++) {\n            nextChild = nextChildren[i];\n            if (nextChild.dom) {\n                nextChild = nextChildren[i] = directClone(nextChild);\n            }\n            mount(nextChild, dom, context, isSVG);\n        }\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; i++) {\n            remove(lastChildren[i], dom);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength) {\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var i;\n    var j = 0;\n    var aNode = a[j];\n    var bNode = b[j];\n    var nextPos;\n    // Step 1\n    // tslint:disable-next-line\n    outer: {\n        // Sync nodes with the same key at the beginning.\n        while (aNode.key === bNode.key) {\n            if (bNode.dom) {\n                b[j] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG);\n            a[j] = bNode;\n            j++;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[j];\n            bNode = b[j];\n        }\n        aNode = a[aEnd];\n        bNode = b[bEnd];\n        // Sync nodes with the same key at the end.\n        while (aNode.key === bNode.key) {\n            if (bNode.dom) {\n                b[bEnd] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG);\n            a[aEnd] = bNode;\n            aEnd--;\n            bEnd--;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[aEnd];\n            bNode = b[bEnd];\n        }\n    }\n    if (j > aEnd) {\n        if (j <= bEnd) {\n            nextPos = bEnd + 1;\n            var nextNode = nextPos < bLength ? b[nextPos].dom : null;\n            while (j <= bEnd) {\n                bNode = b[j];\n                if (bNode.dom) {\n                    b[j] = bNode = directClone(bNode);\n                }\n                j++;\n                insertOrAppend(dom, mount(bNode, null, context, isSVG), nextNode);\n            }\n        }\n    }\n    else if (j > bEnd) {\n        while (j <= aEnd) {\n            remove(a[j++], dom);\n        }\n    }\n    else {\n        var aStart = j;\n        var bStart = j;\n        var aLeft = aEnd - j + 1;\n        var bLeft = bEnd - j + 1;\n        var sources = [];\n        for (i = 0; i < bLeft; i++) {\n            sources.push(0);\n        }\n        // Keep track if its possible to remove whole DOM using textContent = '';\n        var canRemoveWholeContent = aLeft === aLength;\n        var moved = false;\n        var pos = 0;\n        var patched = 0;\n        // When sizes are small, just loop them through\n        if (bLength < 4 || (aLeft | bLeft) < 32) {\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLeft) {\n                    for (j = bStart; j <= bEnd; j++) {\n                        bNode = b[j];\n                        if (aNode.key === bNode.key) {\n                            sources[j - bStart] = i + 1;\n                            if (canRemoveWholeContent) {\n                                canRemoveWholeContent = false;\n                                while (i > aStart) {\n                                    remove(a[aStart++], dom);\n                                }\n                            }\n                            if (pos > j) {\n                                moved = true;\n                            }\n                            else {\n                                pos = j;\n                            }\n                            if (bNode.dom) {\n                                b[j] = bNode = directClone(bNode);\n                            }\n                            patch(aNode, bNode, dom, context, isSVG);\n                            patched++;\n                            break;\n                        }\n                    }\n                    if (!canRemoveWholeContent && j > bEnd) {\n                        remove(aNode, dom);\n                    }\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n        }\n        else {\n            var keyIndex = {};\n            // Map keys by their index\n            for (i = bStart; i <= bEnd; i++) {\n                keyIndex[b[i].key] = i;\n            }\n            // Try to patch same keys\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLeft) {\n                    j = keyIndex[aNode.key];\n                    if (j !== void 0) {\n                        if (canRemoveWholeContent) {\n                            canRemoveWholeContent = false;\n                            while (i > aStart) {\n                                remove(a[aStart++], dom);\n                            }\n                        }\n                        bNode = b[j];\n                        sources[j - bStart] = i + 1;\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.dom) {\n                            b[j] = bNode = directClone(bNode);\n                        }\n                        patch(aNode, bNode, dom, context, isSVG);\n                        patched++;\n                    }\n                    else if (!canRemoveWholeContent) {\n                        remove(aNode, dom);\n                    }\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n        }\n        // fast-path: if nothing patched remove all old and add all new\n        if (canRemoveWholeContent) {\n            removeAllChildren(dom, a);\n            mountArrayChildren(b, dom, context, isSVG);\n        }\n        else {\n            if (moved) {\n                var seq = lis_algorithm(sources);\n                j = seq.length - 1;\n                for (i = bLeft - 1; i >= 0; i--) {\n                    if (sources[i] === 0) {\n                        pos = i + bStart;\n                        bNode = b[pos];\n                        if (bNode.dom) {\n                            b[pos] = bNode = directClone(bNode);\n                        }\n                        nextPos = pos + 1;\n                        insertOrAppend(dom, mount(bNode, null, context, isSVG), nextPos < bLength ? b[nextPos].dom : null);\n                    }\n                    else if (j < 0 || i !== seq[j]) {\n                        pos = i + bStart;\n                        bNode = b[pos];\n                        nextPos = pos + 1;\n                        insertOrAppend(dom, bNode.dom, nextPos < bLength ? b[nextPos].dom : null);\n                    }\n                    else {\n                        j--;\n                    }\n                }\n            }\n            else if (patched !== bLeft) {\n                // when patched count doesn't match b length we need to insert those new ones\n                // loop backwards so we can use insertBefore\n                for (i = bLeft - 1; i >= 0; i--) {\n                    if (sources[i] === 0) {\n                        pos = i + bStart;\n                        bNode = b[pos];\n                        if (bNode.dom) {\n                            b[pos] = bNode = directClone(bNode);\n                        }\n                        nextPos = pos + 1;\n                        insertOrAppend(dom, mount(bNode, null, context, isSVG), nextPos < bLength ? b[nextPos].dom : null);\n                    }\n                }\n            }\n        }\n    }\n}\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n    var p = arr.slice();\n    var result = [0];\n    var i;\n    var j;\n    var u;\n    var v;\n    var c;\n    var len = arr.length;\n    for (i = 0; i < len; i++) {\n        var arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[result.length - 1];\n            if (arr[j] < arrI) {\n                p[i] = j;\n                result.push(i);\n                continue;\n            }\n            u = 0;\n            v = result.length - 1;\n            while (u < v) {\n                c = ((u + v) / 2) | 0;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1;\n                }\n                else {\n                    v = c;\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1];\n                }\n                result[u] = i;\n            }\n        }\n    }\n    u = result.length;\n    v = result[u - 1];\n    while (u-- > 0) {\n        result[u] = v;\n        v = p[v];\n    }\n    return result;\n}\n\nvar documentBody = isBrowser ? document.body : null;\nfunction render(input, parentDom, callback) {\n    if (input === NO_OP) {\n        return;\n    }\n    var rootInput = parentDom.$V;\n    if (isNullOrUndef(rootInput)) {\n        if (!isInvalid(input)) {\n            if (input.dom) {\n                input = directClone(input);\n            }\n            if (isNull(parentDom.firstChild)) {\n                mount(input, parentDom, EMPTY_OBJ, false);\n                parentDom.$V = input;\n            }\n            else {\n                hydrate(input, parentDom);\n            }\n            rootInput = input;\n        }\n    }\n    else {\n        if (isNullOrUndef(input)) {\n            remove(rootInput, parentDom);\n            parentDom.$V = null;\n        }\n        else {\n            if (input.dom) {\n                input = directClone(input);\n            }\n            patch(rootInput, input, parentDom, EMPTY_OBJ, false);\n            rootInput = parentDom.$V = input;\n        }\n    }\n    if (LIFECYCLE.length > 0) {\n        callAll(LIFECYCLE);\n    }\n    if (isFunction(callback)) {\n        callback();\n    }\n    if (isFunction(options.renderComplete)) {\n        options.renderComplete(rootInput);\n    }\n    if (rootInput && rootInput.flags & 14 /* Component */) {\n        return rootInput.children;\n    }\n}\nfunction createRenderer(parentDom) {\n    return function renderer(lastInput, nextInput) {\n        if (!parentDom) {\n            parentDom = lastInput;\n        }\n        render(nextInput, parentDom);\n    };\n}\nfunction createPortal(children, container) {\n    return createVNode(1024 /* Portal */, container, null, children, 0 /* UnknownChildren */, null, isInvalid(children) ? null : children.key, null);\n}\n\nvar resolvedPromise = typeof Promise === 'undefined' ? null : Promise.resolve();\n// raf.bind(window) is needed to work around bug in IE10-IE11 strict mode (TypeError: Invalid calling object)\nvar fallbackMethod = typeof requestAnimationFrame === 'undefined' ? setTimeout : requestAnimationFrame.bind(window);\nfunction nextTick(fn) {\n    if (resolvedPromise) {\n        return resolvedPromise.then(fn);\n    }\n    return fallbackMethod(fn);\n}\nfunction queueStateChanges(component, newState, callback, force) {\n    if (isFunction(newState)) {\n        newState = newState(component.state, component.props, component.context);\n    }\n    var pending = component.$PS;\n    if (isNullOrUndef(pending)) {\n        component.$PS = newState;\n    }\n    else {\n        for (var stateKey in newState) {\n            pending[stateKey] = newState[stateKey];\n        }\n    }\n    if (!component.$PSS && !component.$BR) {\n        if (!component.$UPD) {\n            component.$PSS = true;\n            component.$UPD = true;\n            applyState(component, force, callback);\n            component.$UPD = false;\n        }\n        else {\n            // Async\n            var queue = component.$QU;\n            if (isNull(queue)) {\n                queue = component.$QU = [];\n                nextTick(promiseCallback(component, queue));\n            }\n            if (isFunction(callback)) {\n                queue.push(callback);\n            }\n        }\n    }\n    else {\n        component.$PSS = true;\n        if (component.$BR && isFunction(callback)) {\n            LIFECYCLE.push(callback.bind(component));\n        }\n    }\n}\nfunction promiseCallback(component, queue) {\n    return function () {\n        component.$QU = null;\n        component.$UPD = true;\n        applyState(component, false, function () {\n            for (var i = 0, len = queue.length; i < len; i++) {\n                queue[i].call(component);\n            }\n        });\n        component.$UPD = false;\n    };\n}\nfunction applyState(component, force, callback) {\n    if (component.$UN) {\n        return;\n    }\n    if (force || !component.$BR) {\n        component.$PSS = false;\n        var pendingState = component.$PS;\n        var prevState = component.state;\n        var nextState = combineFrom(prevState, pendingState);\n        var props = component.props;\n        var context = component.context;\n        component.$PS = null;\n        var vNode = component.$V;\n        var lastInput = component.$LI;\n        var parentDom = lastInput.dom && lastInput.dom.parentNode;\n        updateClassComponent(component, nextState, vNode, props, parentDom, context, (vNode.flags & 32 /* SvgElement */) > 0, force, true);\n        if (component.$UN) {\n            return;\n        }\n        if ((component.$LI.flags & 1024 /* Portal */) === 0) {\n            var dom = component.$LI.dom;\n            while (!isNull((vNode = vNode.parentVNode))) {\n                if ((vNode.flags & 14 /* Component */) > 0) {\n                    vNode.dom = dom;\n                }\n            }\n        }\n        if (LIFECYCLE.length > 0) {\n            callAll(LIFECYCLE);\n        }\n    }\n    else {\n        component.state = component.$PS;\n        component.$PS = null;\n    }\n    if (isFunction(callback)) {\n        callback.call(component);\n    }\n}\nvar Component = function Component(props, context) {\n    this.state = null;\n    // Internal properties\n    this.$BR = false; // BLOCK RENDER\n    this.$BS = true; // BLOCK STATE\n    this.$PSS = false; // PENDING SET STATE\n    this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n    this.$LI = null; // LAST INPUT\n    this.$V = null; // VNODE\n    this.$UN = false; // UNMOUNTED\n    this.$CX = null; // CHILDCONTEXT\n    this.$UPD = true; // UPDATING\n    this.$QU = null; // QUEUE\n    /** @type {object} */\n    this.props = props || EMPTY_OBJ;\n    /** @type {object} */\n    this.context = context || EMPTY_OBJ; // context should not be mutable\n};\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\n    if (this.$UN) {\n        return;\n    }\n    // Do not allow double render during force update\n    queueStateChanges(this, {}, callback, true);\n};\nComponent.prototype.setState = function setState (newState, callback) {\n    if (this.$UN) {\n        return;\n    }\n    if (!this.$BS) {\n        queueStateChanges(this, newState, callback, false);\n    }\n    else {\n        return;\n    }\n};\n// tslint:disable-next-line:no-empty\nComponent.prototype.render = function render (_nextProps, _nextState, _nextContext) { };\n\n\n\nvar JSX = /*#__PURE__*/Object.freeze({\n\n});\n\nvar version = \"5.6.1\";\n\n\n\n\n//# sourceURL=webpack:///./node_modules/inferno/dist/index.esm.js?");

/***/ }),

/***/ "./node_modules/inferno/index.esm.js":
/*!*******************************************!*\
  !*** ./node_modules/inferno/index.esm.js ***!
  \*******************************************/
/*! exports provided: Component, EMPTY_OBJ, NO_OP, createComponentVNode, createPortal, createRenderer, createTextVNode, createVNode, directClone, getFlagsForElementVnode, getNumberStyleValue, hydrate, linkEvent, normalizeProps, options, render, version, JSX */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.esm.js */ \"./node_modules/inferno/dist/index.esm.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"Component\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EMPTY_OBJ\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"EMPTY_OBJ\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NO_OP\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"NO_OP\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createComponentVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createComponentVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createPortal\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createPortal\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRenderer\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createRenderer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createTextVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createTextVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createVNode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"createVNode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"directClone\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"directClone\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getFlagsForElementVnode\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"getFlagsForElementVnode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getNumberStyleValue\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"getNumberStyleValue\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"hydrate\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"hydrate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"linkEvent\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"linkEvent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"normalizeProps\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"normalizeProps\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"options\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"version\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"JSX\", function() { return _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__[\"JSX\"]; });\n\n\n\nif (true) {\n  console.warn('You are running production build of Inferno in development mode. Use dev:module entry point.');\n}\n\n\n//# sourceURL=webpack:///./node_modules/inferno/index.esm.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/obj/index.js":
/*!***********************************!*\
  !*** ./node_modules/obj/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = o;\n\nfunction o (obj, par) {\n  if (!(this instanceof o)) return new o(obj, par);\n  this.obj = obj || {};\n  this.par = par;\n}\n\no.prototype.use = c(function (fn) {\n  this.obj = fn(this.obj);\n});\n\no.prototype.set = c(function (key, value) {\n  this.obj[key] = value;\n});\n\no.prototype.get = function (key) {\n  return key\n    ? this.obj[key]\n    : this.obj;\n};\n\no.prototype.sub = function (key) {\n  var obj = this.obj;\n  if (!obj[key]) obj[key] = {};\n  return o(obj[key], this);\n};\n\no.prototype.tmp = function () {\n  return o({}, this);\n};\n\no.prototype.out = function () {\n  return this.par;\n};\n\no.prototype.keys = function () {\n  return Object.keys(this.obj);\n};\n\no.prototype.parEach = c(function (fn) {\n  var self = this;\n  self.par.keys().forEach(function (k) {\n    fn.call(self, k, self.par.get(k));\n  });\n});\n\no.prototype.each = c(function (fn) {\n  var self = this;\n  self.keys().forEach(function (k) {\n    fn.call(self, k, self.get(k));\n  });\n});\n\no.prototype.clone = function () {\n  return this\n    .tmp({})\n    .parEach(function (k, v) { this.set(k, v) });\n};\n\nfunction c (fn) {\n  return function () {\n    fn.apply(this, arguments);\n    return this;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/obj/index.js?");

/***/ }),

/***/ "./node_modules/osm/index.js":
/*!***********************************!*\
  !*** ./node_modules/osm/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var getPosition = __webpack_require__(/*! geo-position */ \"./node_modules/geo-position/index.js\");\nvar base = 'http://www.openstreetmap.org/export/embed.html';\nvar Emitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar inherits = __webpack_require__(/*! util */ \"./node_modules/util/util.js\").inherits;\n\nmodule.exports = Map;\n\nfunction Map () {\n  if (!(this instanceof Map)) return new Map();\n  Emitter.call(this);\n  this.iframe = document.createElement('iframe');\n\n  this._position = null;\n  this._radius = 0.004;\n}\n\ninherits(Map, Emitter);\n\nMap.prototype.radius = function (radius) {\n  this._radius = radius;\n  return this;\n};\n\nMap.prototype.position = function (latitude, longitude) {\n  this._position = {\n    latitude: latitude,\n    longitude: longitude\n  };\n  this.emit('position', this._position);\n  return this;\n};\n\nMap.prototype.show = function () {\n  var self = this;\n  var iframe = self.iframe;\n  var r = self._radius;\n\n  if (self._position) onPosition(null, self._position);\n  else getPosition(function (err, obj) {\n    onPosition(err, obj);\n  });\n  \n  function onPosition (err, position) {\n    if (err) return self.emit('error', err);\n\n    self.emit('position', position);\n\n    var lon = position.longitude;\n    var lat = position.latitude;\n    iframe.src = base\n      + '?layer=mapnik'\n      + '&bbox=' + [lon - r/2, lat - r/4, lon + r/2, lat + r/4].join(',')\n      + '&marker=' + [lat, lon].join(',')\n  }\n\n  return iframe;\n};\n\n\n//# sourceURL=webpack:///./node_modules/osm/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/surface/src/scss/surface_styles.scss":
/*!***********************************************************!*\
  !*** ./node_modules/surface/src/scss/surface_styles.scss ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./node_modules/surface/src/scss/surface_styles.scss?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack:///./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/App.jsx":
/*!*********************!*\
  !*** ./src/App.jsx ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _inferno2 = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\nvar _inferno = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\nvar _ImageUpload = __webpack_require__(/*! ./components/ImageUpload.jsx */ \"./src/components/ImageUpload.jsx\");\n\nvar _ImageUpload2 = _interopRequireDefault(_ImageUpload);\n\nvar _Map = __webpack_require__(/*! ./components/Map.jsx */ \"./src/components/Map.jsx\");\n\nvar _Map2 = _interopRequireDefault(_Map);\n\n__webpack_require__(/*! surface/src/scss/surface_styles.scss */ \"./node_modules/surface/src/scss/surface_styles.scss\");\n\n__webpack_require__(/*! ./App.scss */ \"./src/App.scss\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar App = function (_Component) {\n  _inherits(App, _Component);\n\n  function App(props) {\n    _classCallCheck(this, App);\n\n    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));\n\n    _this.state = {\n      sent: false,\n      url: null\n    };\n\n    _this.handleSend = _this.handleSend.bind(_this);\n    return _this;\n  }\n\n  _createClass(App, [{\n    key: 'handleSend',\n    value: function handleSend(url) {\n      this.setState({ sent: true, url: url });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _state = this.state,\n          sent = _state.sent,\n          url = _state.url;\n\n\n      return (0, _inferno2.createVNode)(1, 'div', 'g--12 no-margin-vertical appMain', [!sent && (0, _inferno2.createVNode)(1, 'div', null, (0, _inferno2.createVNode)(1, 'div', 'sendBlock', (0, _inferno2.createComponentVNode)(2, _ImageUpload2.default, {\n        'onSend': this.handleSend\n      }), 2), 2), sent && (0, _inferno2.createComponentVNode)(2, _Map2.default, {\n        'imgFire': url\n      }), (0, _inferno2.createVNode)(1, 'footer', 'g--12', (0, _inferno2.createVNode)(1, 'div', 'text-center', (0, _inferno2.createTextVNode)('Help us to prevent fire'), 2), 2)], 0);\n    }\n  }]);\n\n  return App;\n}(_inferno.Component);\n\n(0, _inferno.render)((0, _inferno2.createComponentVNode)(2, App), document.getElementById(\"app\"));\n\n//# sourceURL=webpack:///./src/App.jsx?");

/***/ }),

/***/ "./src/App.scss":
/*!**********************!*\
  !*** ./src/App.scss ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/App.scss?");

/***/ }),

/***/ "./src/components/ImageUpload.jsx":
/*!****************************************!*\
  !*** ./src/components/ImageUpload.jsx ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _inferno2 = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\nvar _inferno = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ImageUpload = function (_Component) {\n  _inherits(ImageUpload, _Component);\n\n  function ImageUpload(props) {\n    _classCallCheck(this, ImageUpload);\n\n    var _this = _possibleConstructorReturn(this, (ImageUpload.__proto__ || Object.getPrototypeOf(ImageUpload)).call(this, props));\n\n    _this.state = {\n      url: null\n    };\n\n    _this.handleSelectFile = _this.handleSelectFile.bind(_this);\n    _this.handleButton = _this.handleButton.bind(_this);\n    return _this;\n  }\n\n  _createClass(ImageUpload, [{\n    key: \"handleButton\",\n    value: function handleButton() {\n      this.attachment.click();\n    }\n  }, {\n    key: \"handleSelectFile\",\n    value: function handleSelectFile(input2) {\n      var _this2 = this;\n\n      var reader = new FileReader();\n\n      reader.onload = function (e) {\n        _this2.setState({ url: e.target.result });\n      };\n      reader.readAsDataURL(this.attachment.files[0]);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var url = this.state.url;\n      var onSend = this.props.onSend;\n\n      var attachmentEl = (0, _inferno2.createVNode)(64, \"input\", null, null, 1, {\n        \"type\": \"file\",\n        \"style\": \"display: none;\",\n        \"onchange\": this.handleSelectFile,\n        \"accept\": \".jpg,.jpeg\"\n      }, null, function (attachment) {\n        _this3.attachment = attachment;\n      });\n\n      if (!url) {\n        return (0, _inferno2.createVNode)(1, \"div\", null, [attachmentEl, (0, _inferno2.createVNode)(1, \"button\", \"btn--float btn--red btn-big\", (0, _inferno2.createTextVNode)(\"Shot the fire\"), 2, {\n          \"onClick\": this.handleButton\n        })], 0);\n      }\n\n      return (0, _inferno2.createVNode)(1, \"div\", null, [attachmentEl, (0, _inferno2.createVNode)(1, \"img\", \"user-img\", null, 1, {\n        \"src\": url,\n        \"alt\": \"fire image\"\n      }), (0, _inferno2.createVNode)(1, \"button\", \"btn--red btn-send\", (0, _inferno2.createTextVNode)(\"Send\"), 2, {\n        \"onClick\": function onClick() {\n          return onSend(url);\n        }\n      })], 0);\n    }\n  }]);\n\n  return ImageUpload;\n}(_inferno.Component);\n\nexports.default = ImageUpload;\n\n//# sourceURL=webpack:///./src/components/ImageUpload.jsx?");

/***/ }),

/***/ "./src/components/InfoTable.jsx":
/*!**************************************!*\
  !*** ./src/components/InfoTable.jsx ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _inferno = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\nvar InfoTable = function InfoTable(props) {\n  return (0, _inferno.createVNode)(1, \"table\", \"g--8 card\", [(0, _inferno.createVNode)(1, \"tr\", \"table-header\", [(0, _inferno.createVNode)(1, \"td\", null, (0, _inferno.createTextVNode)(\"Number\"), 2), (0, _inferno.createVNode)(1, \"td\", null, (0, _inferno.createTextVNode)(\"Name\"), 2), (0, _inferno.createVNode)(1, \"td\", null, (0, _inferno.createTextVNode)(\"Age\"), 2), (0, _inferno.createVNode)(1, \"td\", null, (0, _inferno.createTextVNode)(\"Job\"), 2)], 4), (0, _inferno.createVNode)(1, \"tr\", null, [(0, _inferno.createVNode)(1, \"td\", null, (0, _inferno.createTextVNode)(\"521\"), 2), (0, _inferno.createVNode)(1, \"td\", null, (0, _inferno.createTextVNode)(\"Ben\"), 2), (0, _inferno.createVNode)(1, \"td\", null, (0, _inferno.createTextVNode)(\"23\"), 2), (0, _inferno.createVNode)(1, \"td\", null, (0, _inferno.createTextVNode)(\"Front End Dev\"), 2)], 4)], 4);\n};\n\nexports.default = InfoTable;\n\n//# sourceURL=webpack:///./src/components/InfoTable.jsx?");

/***/ }),

/***/ "./src/components/Map.jsx":
/*!********************************!*\
  !*** ./src/components/Map.jsx ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _inferno2 = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\nvar _inferno = __webpack_require__(/*! inferno */ \"./node_modules/inferno/index.esm.js\");\n\nvar _osm = __webpack_require__(/*! osm */ \"./node_modules/osm/index.js\");\n\nvar _osm2 = _interopRequireDefault(_osm);\n\nvar _InfoTable = __webpack_require__(/*! ./InfoTable.jsx */ \"./src/components/InfoTable.jsx\");\n\nvar _InfoTable2 = _interopRequireDefault(_InfoTable);\n\n__webpack_require__(/*! ./Map.scss */ \"./src/components/Map.scss\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Map = function (_Component) {\n  _inherits(Map, _Component);\n\n  function Map() {\n    _classCallCheck(this, Map);\n\n    return _possibleConstructorReturn(this, (Map.__proto__ || Object.getPrototypeOf(Map)).apply(this, arguments));\n  }\n\n  _createClass(Map, [{\n    key: 'render',\n    value: function render() {\n      var imgFire = this.props.imgFire;\n\n      var map = (0, _osm2.default)().position(48.5263832, 32.2718125).radius(0.1);\n      map.show();\n      console.log(map.iframe.src);\n\n      return (0, _inferno2.createVNode)(1, 'div', 'map-block', [(0, _inferno2.createVNode)(1, 'div', 'map', (0, _inferno2.createVNode)(1, 'iframe', null, null, 1, {\n        'src': map.iframe.src\n      }), 2), (0, _inferno2.createVNode)(1, 'div', 'info container', [(0, _inferno2.createVNode)(1, 'div', 'g--3', (0, _inferno2.createVNode)(1, 'img', 'user-img, map-image', null, 1, {\n        'src': imgFire,\n        'alt': 'fire image'\n      }), 2), (0, _inferno2.createComponentVNode)(2, _InfoTable2.default)], 4)], 4);\n    }\n  }]);\n\n  return Map;\n}(_inferno.Component);\n\n;\n\nexports.default = Map;\n\n//# sourceURL=webpack:///./src/components/Map.jsx?");

/***/ }),

/***/ "./src/components/Map.scss":
/*!*********************************!*\
  !*** ./src/components/Map.scss ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/components/Map.scss?");

/***/ })

/******/ });